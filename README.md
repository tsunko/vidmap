# Vidmap
### Another attempt at videos on Minecraft maps

Just as full disclosure: I am also the original author for [this](https://www.youtube.com/watch?v=mehz11F6BJs).

# What is Vidmap?
A proof of concept implementation of streaming video to Minecraft maps with the ability to play audio! Streaming videos to maps is _not_ practical, due to massive bandwidth usage and required throughput. The audio part of this project might be a good starting point in creating a "radio" in-game though.

# Videos!? On maps!?
Yes, we utilize FFmpeg's libraries to decode video frames in a frame-by-frame fashion. This is mainly due to the fact that FFmpeg has high performance, support for many codecs, and relative ease-of-use (relative in that documentation for FFmpeg is sparse and is lacking in several areas). Frames are automagically dithered by FFmpeg. 

We can then exploit the fact that our video frame's color space is going to be 16-bits due to swscale (ARGB4444) and can utilize the pixel data directly to index into a small 4kb lookup table. This lookup table is generated outside of VidMap (see: `lut-main.zig` and `color.zig`). Each lookup entry was generated by comparing each supported Minecraft map color and every possible 16-bit pixel color by the way of converting RGB values to XYZ and then XYZ to CIELab. The CIELab values are then compared against using CIE's Delta E (specifically, the 2000 variant) for as much accuracy as possible (though, as mentioned within the comments, this ironically may lead to loss of accuracy due to the conversion process).

# Audios!? Custom audio!?
Yup, we got audio too. Extremely large disclaimer: the audio and video will **make no attempt to synchronize.** This is due to the fact that we cannot arbitrarily send audio data to the client. This is achieved in two steps:

* Extract the audio from the container using FFmpeg and re-encode the audio into Ogg Vorbis.
* Generate a resource pack at runtime and serve the resource pack to the player.

By doing this, we can playback audio that corresponds to the video being played, with some caveats (such as inability to synchronize).

## What's different with this than the original?
* No longer needs to generate a GIF for the entire video and then read each GIF frame one at a time - just read and decode straight from the video file.
* Since we directly read and decode from the video with FFmpeg, we don't need to use Sun's internal GIF decoder.
* Scaling past 1 map is now possible, so that we can achieve larger displays without too much of a performance penalty (the old version _was_ able to scale past 1 map, but had terrible performance).
* No longer bound by a hardcoded, fixed framerate - Vidmap matches the source video, so 60FPS videos will attempt to play at 60FPS, 24FPS will attempt to play at 24FPS.
* A downside is that we're no longer able to directly hook up things like Java-based GameBoy emulators directly to this version, as we now rely directly on FFmpeg to do video decoding legwork.

## Tools and Libraries
This is a dual-language project. Since Bukkit is Java-based, I stuck with implementing the bridge and plugin in Java. The other half is written in [Zig](https://ziglang.org/), a super cool language that does Great Justice(tm) for the problems with C. I highly recommend you check it out - this project would've been much more buggy and annoying to write if the library was written in C/C++. To link the two worlds together, we use the bog standard JNI interface for loading and executing Zig code from Java.

As for libraries, I currently use the aforementioned FFmpeg's libraries (avcodec, avformat, avutil, swresample, swscale) and Zig's standard library with some self-written mini-libraries (while it's part of the source code, most of the files within the Zig section can be used elsewhere - they're in no way coupled tightly together). We do also utilize the internal Sun HTTP server for serving resource packs - however, I'd imagine it'd be relatively easy to write in a replacement if needed.

Optionally, SDL2 is used to "debug" videos by the way of emulating the Minecraft map colorspace (read frame -> match color -> translate Minecraft color back to ARGB4444 value -> update SDL2 texture).

## Build instructions
Essentially, there is no real build instructions. If you know how to setup Bukkit plugins and how to package them, then you have the neccessary tools and information at your disposal. I am deliberatly not providing instructions or precompiled/prepackaged binaries due to the fact that this project is a proof-of-concept, not something meant to be used publicly. Plus, even if I did release binaries, should you really trust a random guy on the internet claiming to do something extroidinary? You have the source code - explore it :) In the future, I may come back to this and provide real instructions so that anyone may build this, but for now, I'd advise against trying to force this to work.

For the quick, dirty build instructions:
* There are several hardcoded values - this is something I'm working on removing, but for now, you'll have to change the `source` value in `VidmapPlugin.java` and `Root` in `build.zig`.
* Throw a shared-build of FFmpeg into `nativemap/ffmpeg` so we can import its headers and link against its libraries.
* Throw JNI headers into `nativemap/jni`
* Optionally, throw SDL2 into `nativemap/sdl2` if you want to build the debug video player.
* Use "zig build" to build the project. You can select what you want to build by either providing "-Dsdl" for the SDL2 debug player, "-Dlut" for the lookup table generator, or "-Dlib" to compile the DLL neccessary for VidMap to load.
* If you build the lookup table generator, you'll need to manually invoke it. It'll be named "lut-gen.exe" and will be residing in `nativemap/zig-out/bin/`.
* The SDL2-based debug player will be in the same directory as the lookup table generator. Invoke it like so: `sdl-debug-player <your video file here>`. Note: it will not playback audio, but it will output the extracted and re-encoded audio as `test.ogg`. It will always always be 720p.
* If you build the DLL, you need to copy the DLL and FFmepg's DLLs into the root of your server. 
* Do the usual song and dance to package the Java plugin component.
* Start up Minecraft and log into your server.
* The command to start a video is `/do-video <width> <height> <file>`, where `width` and `height` is how big your map display is (each map is 128x128 pixels - if you want a 128x128 display, then `width`=1, `height`=1).
* You can stop a running video with `/stop-video`. It will not stop the audio though.

## Limitations
* Autodithering is done by FFmpeg, however, I cannot find a way to turn off dithering when using ARGB4444. swscale's source code has references to the "sws_dither" AVOption, but setting it seems to have no effect.
* It is incredibly taxing on the network to stream videos. I would highly not recommend running this for anything more than seeing it yourself. It is also incredibly taxing on the client to have to update multiple maps multiple times per second. If I had to set a "limit" on who you can show this, I would recommend only using this within the confines of your own network.
* As mentioned before, audio can video cannot be synchronized. One possibility is to divide the audio into multiple, 1-second chunks and then playing each audio clip back every second. With this, you can synchronize to at least every second.
* Very large in-game map "displays" _will_ cause performance issues for the client (basically: you can DoS a client unintentionally). The size of "very large" will be dependent on your computer. With an AMD Ryzen 3600X and NVIDIA GTX 980, you can playback to 1080p-equivalent (15 x 8 map display) displays at 60FPS with little to no issue, assuming your server is hosted on localhost. Scaling this to a 4k-equivalent (30 x 17), results in the client locking up from the sheer amount of data it is processing (napkin math: 4k-equivalent @ 24FPS results in **over 200MB/s**). The client was simply not designed to handle this much information (nor should it, honestly - when are you going to ever require that much throughput with Minecraft).